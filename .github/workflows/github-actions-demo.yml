name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out UiPath tests with GitHub Actions ðŸš€
on: [push]
jobs:
  provide_packages_json:
    runs-on: self-hosted
    # here, we save the result of this 1st phase to the "outputs"
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
            
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
              
      - name: Run script to create test matrix
        id: set-matrix
        shell: pwsh
        env:
            CLIENT_ID: ${{ secrets.CLIENT_ID }}
            CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
            SCOPE: ${{ secrets.SCOPE }}
            OR_TENANT: ${{ vars.OR_TENANT }}
            ACCOUNTFORAPP: ${{ vars.ACCOUNTFORAPP }}
            OR_URL: ${{ vars.OR_URL }}
            
        run: |
          $cmdOutput = (.\getTestSets.ps1)
          echo "matrix=$cmdOutput"
          echo "::set-output name=matrix::$($cmdOutput)"
       
  run_tests:
    name: Run test set ${{ matrix.testsetname }} in folder ${{ matrix.orgunitname }}
    needs: provide_packages_json
    permissions: write-all
    runs-on: self-hosted
    strategy:
      # â†“ the real magic happens here - create dynamic matrix from the json
      matrix: ${{ fromJson(needs.provide_packages_json.outputs.matrix) }}
    steps:
       - name: Checkout repository
         uses: actions/checkout@v2

       - name: Setup UiPath CLI
         uses: Mikael-RnD/setup-uipath@v1.1.37
      
       - name: Run UiPath Test Set 
         shell: pwsh
         env:
            CLIENT_ID: ${{ secrets.CLIENT_ID }}
            CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
            SCOPE: ${{ secrets.SCOPE }}
            OR_TENANT: ${{ vars.OR_TENANT }}
            ACCOUNTFORAPP: ${{ vars.ACCOUNTFORAPP }}
         run: uipcli.exe test run "https://cloud.uipath.com/" ${{env.OR_TENANT}} --accountForApp ${{env.ACCOUNTFORAPP}} --applicationId ${{env.CLIENT_ID}} --applicationSecret "${{env.CLIENT_SECRET}}" --applicationScope "${{env.SCOPE}}" --testset ${{ matrix.testsetname }} --organizationUnit ${{ matrix.orgunitname }} --traceLevel Verbose --attachRobotLogs --result_path ".\TestResults\TEST-${{ matrix.testsetname }}.xml"  --out junit  

       - name: Upload test result
         uses: actions/upload-artifact@v2
         if: always() # This makes sure the step always runs, even if the prior step fails.
         with:
           name: junit-results-${{ matrix.node-version }}
           path: TestResults/TEST-*.xml
           
  merge-results:
    needs: run_tests
    runs-on: ubuntu-latest
  
    steps:
      - name: Download all workflow run artifacts
        uses: actions/download-artifact@v2

      - name: Generate Test Report
        uses: dorny/test-reporter@v1
        if: success() || failure()    # run this step even if previous step failed
        with:
          name: Test Report for Test Set ${{ matrix.testsetname }} in folder ${{ matrix.orgunitname }}            # Name of the check run which will be created
          path: TEST-*.xml    # Path to test results
          reporter: java-junit        # Format of test results
           
